import logging
from typing import List, Optional
from models.entities import Vulnerability
from models.repository_factory import repository_factory

logger = logging.getLogger(__name__)


class VulnerabilityService:
    """Сервис для работы с уязвимостями через PostgreSQL"""

    def __init__(self):
        self.repo_factory = repository_factory
        self.vulnerability_repo = self.repo_factory.create_vulnerability_repository()
        logger.info("VulnerabilityService initialized with PostgreSQL")

    def get_all_vulnerabilities(self) -> List[Vulnerability]:
        """Получить все уязвимости"""
        try:
            return self.vulnerability_repo.get_all()
        except Exception as e:
            logger.error(f"Error getting all vulnerabilities: {e}")
            return []

    def get_vulnerability_by_id(self, vuln_id: int) -> Optional[Vulnerability]:
        """Получить уязвимость по ID"""
        try:
            return self.vulnerability_repo.get_by_id(vuln_id)
        except Exception as e:
            logger.error(f"Error getting vulnerability {vuln_id}: {e}")
            return None

    def get_vulnerability_by_title(self, title: str) -> Optional[Vulnerability]:
        """Найти уязвимость по заголовку"""
        try:
            return self.vulnerability_repo.get_by_title(title)
        except Exception as e:
            logger.error(f"Error getting vulnerability by title '{title}': {e}")
            return None

    def assign_vulnerability(self, vuln_id: int, operator_id: int) -> bool:
        """Назначить уязвимость оператору"""
        try:
            return self.vulnerability_repo.assign_operator(vuln_id, operator_id)
        except Exception as e:
            logger.error(f"Error assigning vulnerability {vuln_id} to operator {operator_id}: {e}")
            return False

    def unassign_vulnerability(self, vuln_id: int) -> bool:
        """Снять назначение с уязвимости"""
        try:
            return self.vulnerability_repo.unassign_operator(vuln_id)
        except Exception as e:
            logger.error(f"Error unassigning vulnerability {vuln_id}: {e}")
            return False

    def approve_vulnerability(self, vuln_id: int) -> bool:
        """Одобрить уязвимость"""
        try:
            vuln = self.get_vulnerability_by_id(vuln_id)
            if vuln:
                vuln.mark_approved()
                return self.vulnerability_repo.update(vuln)
            return False
        except Exception as e:
            logger.error(f"Error approving vulnerability {vuln_id}: {e}")
            return False

    def complete_vulnerability(self, vuln_id: int) -> bool:
        """Завершить уязвимость"""
        try:
            vuln = self.get_vulnerability_by_id(vuln_id)
            if vuln:
                vuln.mark_completed()
                return self.vulnerability_repo.update(vuln)
            return False
        except Exception as e:
            logger.error(f"Error completing vulnerability {vuln_id}: {e}")
            return False

    def request_modification(self, vuln_id: int) -> bool:
        """Запросить модификацию уязвимости"""
        try:
            vuln = self.get_vulnerability_by_id(vuln_id)
            if vuln:
                vuln.request_modification()
                return self.vulnerability_repo.update(vuln)
            return False
        except Exception as e:
            logger.error(f"Error requesting modification for vulnerability {vuln_id}: {e}")
            return False

    def update_vulnerability(self, vuln_id: int, **kwargs) -> bool:
        """Обновить уязвимость"""
        try:
            vuln = self.get_vulnerability_by_id(vuln_id)
            if vuln:
                for key, value in kwargs.items():
                    if hasattr(vuln, key):
                        setattr(vuln, key, value)
                return self.vulnerability_repo.update(vuln)
            return False
        except Exception as e:
            logger.error(f"Error updating vulnerability {vuln_id}: {e}")
            return False

    def add_vulnerability(self, vulnerability: Vulnerability) -> bool:
        """Добавить новую уязвимость"""
        try:
            return self.vulnerability_repo.add(vulnerability)
        except Exception as e:
            logger.error(f"Error adding vulnerability '{vulnerability.title}': {e}")
            return False

    def get_vulnerabilities_count(self) -> int:
        """Получить общее количество уязвимостей"""
        try:
            return len(self.vulnerability_repo.get_all())
        except Exception as e:
            logger.error(f"Error getting vulnerabilities count: {e}")
            return 0

    def get_vulnerabilities_by_status(self, status: str) -> List[Vulnerability]:
        """Получить уязвимости по статусу"""
        try:
            return self.vulnerability_repo.get_by_status(status)
        except Exception as e:
            logger.error(f"Error getting vulnerabilities by status '{status}': {e}")
            return []

    def get_vulnerabilities_by_severity(self, severity: str) -> List[Vulnerability]:
        """Получить уязвимости по уровню серьезности"""
        try:
            return self.vulnerability_repo.get_by_severity(severity)
        except Exception as e:
            logger.error(f"Error getting vulnerabilities by severity '{severity}': {e}")
            return []