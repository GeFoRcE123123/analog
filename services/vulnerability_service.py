import logging
from typing import List, Optional, Tuple
from models.entities import Vulnerability
from models.repository_factory import repository_factory
from models.optimized_postgres_repositories import OptimizedPostgresVulnerabilityRepository

logger = logging.getLogger(__name__)


class VulnerabilityService:
    """Сервис для работы с уязвимостями через PostgreSQL"""

    def __init__(self, use_optimized: bool = False):
        self.use_optimized = use_optimized
        if use_optimized:
            self.vulnerability_repo = OptimizedPostgresVulnerabilityRepository()
            logger.info("VulnerabilityService initialized with optimized PostgreSQL")
        else:
            self.repo_factory = repository_factory
            self.vulnerability_repo = self.repo_factory.create_vulnerability_repository()
            logger.info("VulnerabilityService initialized with standard PostgreSQL")

    def get_all_vulnerabilities(self) -> List[Vulnerability]:
        """Получить все уязвимости (ограничено для предотвращения перегрузки)"""
        try:
            return self.vulnerability_repo.get_all()
        except Exception as e:
            logger.error(f"Error getting all vulnerabilities: {e}")
            return []

    def get_all_vulnerabilities_unlimited(self) -> List[Vulnerability]:
        """Получить все уязвимости без ограничений (для аналитики)"""
        try:
            if self.use_optimized:
                return self.vulnerability_repo.get_all_unlimited()
            else:
                return self.vulnerability_repo.get_all_unlimited()
        except Exception as e:
            logger.error(f"Error getting all vulnerabilities (unlimited): {e}")
            return []

    def get_paginated_vulnerabilities(self, page: int = 1, per_page: int = 50,
                                   status: Optional[str] = None, severity: Optional[str] = None,
                                   search: Optional[str] = None) -> Tuple[List[Vulnerability], int]:
        """Получить уязвимости с пагинацией и фильтрацией"""
        try:
            # Передаем только непустые параметры
            return self.vulnerability_repo.get_paginated(
                page=page, 
                per_page=per_page,
                status=status if status else None,
                severity=severity if severity else None,
                search=search if search else None
            )
        except Exception as e:
            logger.error(f"Error getting paginated vulnerabilities: {e}")
            return [], 0

    def get_vulnerability_by_id(self, vuln_id: int) -> Optional[Vulnerability]:
        """Получить уязвимость по ID"""
        try:
            return self.vulnerability_repo.get_by_id(vuln_id)
        except Exception as e:
            logger.error(f"Error getting vulnerability {vuln_id}: {e}")
            return None

    def get_vulnerability_by_title(self, title: str) -> Optional[Vulnerability]:
        """Найти уязвимость по заголовку"""
        try:
            return self.vulnerability_repo.get_by_title(title)
        except Exception as e:
            logger.error(f"Error getting vulnerability by title '{title}': {e}")
            return None

    def assign_vulnerability(self, vuln_id: int, operator_id: int) -> bool:
        """Назначить уязвимость оператору"""
        try:
            return self.vulnerability_repo.assign_operator(vuln_id, operator_id)
        except Exception as e:
            logger.error(f"Error assigning vulnerability {vuln_id} to operator {operator_id}: {e}")
            return False

    def unassign_vulnerability(self, vuln_id: int) -> bool:
        """Снять назначение с уязвимости"""
        try:
            return self.vulnerability_repo.unassign_operator(vuln_id)
        except Exception as e:
            logger.error(f"Error unassigning vulnerability {vuln_id}: {e}")
            return False

    def approve_vulnerability(self, vuln_id: int) -> bool:
        """Одобрить уязвимость"""
        try:
            vuln = self.get_vulnerability_by_id(vuln_id)
            if vuln:
                vuln.mark_approved()
                return self.vulnerability_repo.update(vuln)
            return False
        except Exception as e:
            logger.error(f"Error approving vulnerability {vuln_id}: {e}")
            return False

    def complete_vulnerability(self, vuln_id: int) -> bool:
        """Завершить уязвимость"""
        try:
            vuln = self.get_vulnerability_by_id(vuln_id)
            if vuln:
                vuln.mark_completed()
                return self.vulnerability_repo.update(vuln)
            return False
        except Exception as e:
            logger.error(f"Error completing vulnerability {vuln_id}: {e}")
            return False

    def request_modification(self, vuln_id: int) -> bool:
        """Запросить модификацию уязвимости"""
        try:
            vuln = self.get_vulnerability_by_id(vuln_id)
            if vuln:
                vuln.request_modification()
                return self.vulnerability_repo.update(vuln)
            return False
        except Exception as e:
            logger.error(f"Error requesting modification for vulnerability {vuln_id}: {e}")
            return False

    def update_vulnerability(self, vuln_id: int, **kwargs) -> bool:
        """Обновить уязвимость"""
        try:
            vuln = self.get_vulnerability_by_id(vuln_id)
            if vuln:
                for key, value in kwargs.items():
                    if hasattr(vuln, key):
                        setattr(vuln, key, value)
                return self.vulnerability_repo.update(vuln)
            return False
        except Exception as e:
            logger.error(f"Error updating vulnerability {vuln_id}: {e}")
            return False

    def add_vulnerability(self, vulnerability: Vulnerability) -> bool:
        """Добавить новую уязвимость"""
        try:
            return self.vulnerability_repo.add(vulnerability)
        except Exception as e:
            logger.error(f"Error adding vulnerability '{vulnerability.title}': {e}")
            return False

    def get_vulnerabilities_count(self) -> int:
        """Получить общее количество уязвимостей"""
        try:
            return len(self.vulnerability_repo.get_all())
        except Exception as e:
            logger.error(f"Error getting vulnerabilities count: {e}")
            return 0

    def get_vulnerabilities_by_status(self, status: str) -> List[Vulnerability]:
        """Получить уязвимости по статусу"""
        try:
            return self.vulnerability_repo.get_by_status(status)
        except Exception as e:
            logger.error(f"Error getting vulnerabilities by status '{status}': {e}")
            return []

    def get_vulnerabilities_by_severity(self, severity: str) -> List[Vulnerability]:
        """Получить уязвимости по уровню серьезности"""
        try:
            return self.vulnerability_repo.get_by_severity(severity)
        except Exception as e:
            logger.error(f"Error getting vulnerabilities by severity '{severity}': {e}")
            return []